#!/usr/bin/env node
"use strict";

/**
 * Native modules.
 */

var fs = require('fs')
  , path = require('path');

/**
 * Third party modules.
 */

var _ = require('lodash')
  , color = require('colors')
  , program = require('commander');

/**
 * Square library internals.
 */

var Square = require('../lib/square')
  , square = new Square({ cli: true });

// Do we need to silence all the output because we spit the shit to std out?
// This needs to be checked before we parse the argv's using commander so we can
// silence the output before that.
program.silence = ~process.argv.indexOf('--output') || ~process.argv.indexOf('-o');

/**
 * Argument filters for commander.
 *
 * @type {Object}
 * @api private
 */

var filters = {
    /**
     * Split the supplied argument to create a list (array).
     *
     * @param {String} val the command line flag value
     * @returns {Array}
     * @api private
     */

    list: function list (val) {
      return val.split(',');
    }

    /**
     * Checks if the given option should be ignored.
     *
     * @param {Mixed} ignore
     * @api private
     */

  , ignore: function ignoring (ignore) {
      return ~this.indexOf(ignore);
    }
};

// Setup the command line interface.
program
  .version(require('../package.json').version)
  .usage('[options]')
  .option('-b, --bundle <dir/file.json>', 'the location of the package file')
  .option('-e, --extension <extension>', 'filter on this file extension')
  .option('-w, --watch [port]', 'watch the bundled files for changes and rebuild', parseInt)
  .option('-o, --output', 'output the contents to stdout instead of a file')

  // options that require argument filtering
  .option('-p, --plugins <plugins>', 'which plugins should be included', filters.list)
  .option('-g, --group <groups>', 'which groups should be processed', filters.list)
  .option('-l, --list', 'show a list of plugins');

/**
 * Adding some basic commands.
 */

program
  .command('init')
  .description('initialize an empty project'.grey)
  .action(function action () {
    program.commands_exec = true;

    require('./initialize')(program, square);
  });

/**
 * Display addition help information.
 */

program.on('--help', function help () {
  console.log('');
  console.log('  Examples:');

  console.log('');
  console.log([
      '    # Building for development with multiple plugins \n'.grey
    , '    square --bundle '.cyan
    , './'.white
    , ' --plugins '.cyan
    , 'debug,crush'.white
  ].join(''));

  console.log('');
  console.log([
      '    # Only build css files \n'.grey
    , '    square --bundle '.cyan
    , './other/directory'.white
    , ' --plugins '.cyan
    , 'crush'.white
    , ' --extension '.cyan
    , 'css'.white
  ].join(''));

  process.exit();
});

/**
 * Start watching files for changes, but only if we have actually done one
 * successful build before.
 *
 * @param {Boolean} live live reloading
 * @api private
 */

program.on('--watch', function watching (live) {
  var watch = require('../lib/watch')
    , socket = live && typeof live === 'number'
      ? watch.live.call(square, live)
      : null;

  square.once('build', function builded () {
    var configuration = square.package.configuration
      , extensions = configuration.watch || [ program.extension || 'js' ];

    // notify the user that we started watching for file changes
    square.logger.info(
        'watching bundled *.%s for file changes'
      , (extensions.length ? extensions[0] : '*').yellow
    );

    // we want to find every single directory that has files for our bundle so
    // we can actually search for those files and generate new files..
    var files = Object.keys(square.package.bundle).map(function map(file) {
      return square.package.bundle[file].meta.location;
    });

    // start watching for file changes in the given directory
    watch(files, extensions, function update (err, files) {
      if (err) return square.logger.error(
          'Watcher error %s, canceling watch operations on %s'
        , err.message, files
      );

      // empty line
      console.log('');
      square.logger.notice('changes detected, refreshing %s', files.join(', '));

      square.refresh(files);
      square.build(program.extension, program.group, function finished (changes) {
        // check if we are listening for live changes, if so, emit the changes
        if (!socket) return;

        socket.emit('refresh', changes);
      });
    });
  });
});

/**
 * Show a list of active plugins.
 *
 * @api private
 */

program.on('--list', function plugins () {
  /**
   * Pad a string.
   *
   * @param {String} str
   * @param {Number} len
   * @param {String} prefix
   * @returns {String}
   * @api private
   */

  function pad (str, len, prefix) {
    str = '' + str;
    prefix = prefix || '    ';
    return prefix + str + (new Array(len - str.length + 1).join(' '));
  }

  var dir = path.join(__dirname, '../plugins')
    , files = require('fs').readdirSync(dir)
    , len;

  // remove pointless shit form the list
  files = files.filter(function filter (file) {
    return (/\.js$/).test(file);
  });

  // calculate maximum length of the plugin names
  len = Math.max.apply(Math, files.map(function max (file) {
    return file.length;
  }));

  console.log('  Available plugins:');
  console.log('');

  files.forEach(function (file) {
    var plugin = require(dir + '/' + file)
      , name = file.replace(/\.js$/, '')
      , description = plugin.description
      , line = [ pad(name, len) ]
      , count = 0
      , words;

    if (!description) return;

    description = description.toLowerCase().words();
    while (description.length) {
      count++;
      words = description.splice(0, 15);
      words = words.join(' ');

      if (count !== 1) {
        line.push('\n' + words.padLeft(' ', len + 4));
      } else {
        line.push(words);
      }
    }

    console.log(line.join(''));
  });

  process.exit(0);
});

// output the help if it's called without arguments
if (!process.argv.slice(2).length) process.argv.push('--help');

// output a fancy pancy logo, [square] for le win.
if (!program.silence)
[
    ''
  , 'o-o  o-o o  o o-o o-o o-o '.cyan
  , ' \\  |  | |  | |-| |   |- '.cyan + ('      version: ' + program._version).white
  , 'o-o  o-O o--o o o-o   o-o '.cyan
  , '       |                  '.cyan
  , '       o                  '.cyan
  , ''
].forEach(function each (line) {
  console.log('  ' + line);
});

// all the event listeners are attached can we can start parsing the arguments, as
// this a sync call, we need to be 100% sure that every listener is added.
program.parse(process.argv);

//Set some defaults based on the flags.
program.group = Array.isArray(program.group)
  ? program.group
  : [];

program.bundle = program.bundle || process.env.PWD;

program.plugins = Array.isArray(program.plugins)
  ? program.plugins
  : [];

// how do we need to output data
square.stdout = !!program.output;

// Trigger some events based on the params.
if (program.watch) program.emit('--watch', program.watch);
if (program.list) program.emit('--list', program.list);

/**
 * Display a not found message.
 *
 * @api private
 */

program.notFound = function notFound () {
 [
    'We are unable to find the '.white
    + (program.filename.join('.json, ') + '.json').red
    + ' files.'.white
  , ''
  , 'Please double check if these files are located in the '.white
    + program.bundle.red
    + ' directory.'.white
  , 'Thanks for flying Square.'.white
 ].forEach(function output (line) {
    square.logger.error(line);
 });
};

// Check if an command is currently being executed, because we don't have to
// start building the resting the data if this the case.
//
// This is for example the case for the init/bootstrap commands.
if (program.commands_exec) return;

// Make sure that the bundle location exists, so we don't get any ENOENT errors
if (!fs.existsSync(program.bundle)) return program.notFound();

// Start search the given directory tree for square.json files. If we cannot
// parse the bundle we are just gonna return because don't need to do any more
// processing in this run.
if (!square.parse(program.bundle)) return;


/**
 * Called when our version is no longer the same version as our upstream
 * repository.
 *
 * @param {String} latest upstream version
 * @param {String} current current version
 */

function outofdate(latest, current) {
  [
     'The [square] build system is out of date, the latest version is '.white
      + latest.green + '.'.white
    , 'but you are still running version '.white + current.red
      + '. Please consider upgrading to the'
    , 'latest version to receive all bugfixes and new features.'
    , ''
    , 'type: '.white + 'npm install square -g'.green
      + ' to download the latest version.'.white
    , ''
  ].forEach(function log (line) {
    square.logger.warning(line);
  });
}

// process the plugins
program.plugins.forEach(function load (plugin) {
  square.plugin(plugin);
});

square
  .once('outofdate', outofdate)
  .outofdate(true)
  .build();
